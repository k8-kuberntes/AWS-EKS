---
- hosts: localhost
  connection: local
  become: no
  gather_facts: yes
  vars:
    ecs_vpc_subnets: ['subnet-0c75f422','subnet-51de941b']
    cloudwatch_namespace: "/ecs/{{ ecs_cluster_name }}-{{ ecs_env }}"
    ecs_cluster_name: sg_gearup_dev
    ecs_cluster_create_delete: present
    ecs_instance_type:  t2.xlarge
    ecs_ec2_region: us-east-1
    ecs_ssh_key_name:  "custom_ami_key"
    ecs_ami_id: "ami-03755a844de4046b6"
    ecs_assign_public_ip: true
    ecs_asg_name: "{{ ecs_cluster_name }}-asg"
    ecs_asg_min_size: 2
    ecs_asg_max_size: 2
    ecs_asg_desired_capacity: 2
    ecs_asg_default_cooldown: 300
    ecs_security_groups: ["sg-08427337db493a8d6"]
    ecs_ec2_tags:
      - Name: "ecs-cluster-host"
    ecs_asg_replace_all_instances: yes
    ecs_asg_health_check_period: 60
    ecs_asg_health_type: EC2
    ecs_env: development
    ecs_alb_name: sg-dev-test








  tasks:
  - name: Creating cluster if not exist
    ecs_cluster:
      name: '{{ecs_cluster_name}}'
      state: '{{ecs_cluster_create_delete}}'
    register: cluster_status

  - name: get the cluster varaibes Arn
    debug: var=cluster_status.cluster.clusterArn

  - name: get the cluster varaibes name
    debug: var=cluster_status.cluster.clusterName

  - name: get the cluster varaibes STATUS
    debug: var=cluster_status.cluster.status

  - name: Application | Network  Load Balancer target Group Creation
    elb_target_group:
        name: '{{ecs_alb_name}}-targetgroup' # required. The name of the target group.
        state: '{{ecs_cluster_create_delete}}' # required. choices: present;absent. Create or destroy the target group.
        protocol: http
        port: 80
        health_check_path: /api/status
        health_check_interval: 300
        health_check_timeout: 5
        healthy_threshold_count: 5
        unhealthy_threshold_count: 2
        health_check_protocol: http
        health_check_port: 3000 #The port on which each target receives traffic from the load balancer. # not required. The port the load balancer uses when performing health checks on targets. Can be set to 'traffic-port' to match target port.
        successful_response_codes: "200"
        target_type: instance
        vpc_id: vpc-79e13703
        stickiness_enabled: True
        wait_timeout: 200 # not required. The time to wait for the target group.
    register: elb_target_group

  - name: get the elb target arn values
    debug: var=elb_target_group.target_group_arn


  # - name: creating Application Load Blancer
  #   ec2_elb_lb:
  #       name: '{{ecs_alb_name}}-App' # required. The name of the ELB
  #       state: '{{ecs_cluster_create_delete}}' # required. choices: present;absent. Create or destroy the ELB
  #       subnets: '{{ecs_vpc_subnets}}' # not required. A list of VPC subnets to use when creating ELB. Zones should be empty if using this.
  #       health_check: undefined # not required. An associative array of health check configuration settings (see example)
  #       tags: "{{ ecs_ec2_tags }}"  # not required. An associative array of tags. To delete all tags, supply an empty dict.
  #       listeners:
  #         - protocol: http
  #           load_balancer_port: 80
  #           instance_port: 80
  #       idle_timeout: 60 # not required. ELB connections from clients and to servers are timed out after this amount of time
  #       wait_timeout: 60 # not required. Used in conjunction with wait. Number of seconds to wait for the elb to be terminated. A maximum of 600 seconds (10 minutes) is allowed.
  #       cross_az_load_balancing: yes # not required. Distribute load across all configured Availability Zones
  #       security_group_ids: '{{ecs_security_groups}}' # not required. A list of security groups to apply to the elb
  #       wait: no # not required. When specified, Ansible will check the status of the load balancer to ensure it has been successfully removed from AWS.
  #       scheme: "internet-facing" # not required. choices: internal;internet-facing. The scheme to use when creating the ELB. For a private VPC-visible ELB use 'internal'. If you choose to update your scheme with a different value the ELB will be destroyed and recreated. To update scheme you must use the option wait.
  #       # stickiness: undefined # not required. An associative array of stickiness policy settings. Policy will be applied to all listeners ( see example )

  - name: Create an Application Load Balancer
    elb_application_lb:
        name: '{{ecs_alb_name}}-App' # required. The name of the load balancer. This name must be unique within your AWS account, can have a maximum of 32 characters, must contain only alphanumeric characters or hyphens, and must not begin or end with a hyphen.
        subnets: '{{ecs_vpc_subnets}}' # not required. A list of the IDs of the subnets to attach to the load balancer. You can specify only one subnet per Availability Zone. You must specify subnets from at least two Availability Zones. Required if state=present.
        idle_timeout: 60 # not required. The number of seconds to wait before an idle connection is closed.
        wait_timeout: 60 # not required. The time in seconds to use in conjunction with I(wait).
        security_groups:  '{{ecs_security_groups}}'  # not required. A list of the names or IDs of the security groups to assign to the load balancer. Required if state=present.
        wait: false # not required. Wait for the load balancer to have a state of 'active' before completing. A status check is performed every 15 seconds until a successful state is reached. An error is returned after 40 failed checks.
        listeners:
          - Protocol: HTTPS
            Port: 443
            DefaultActions:
              - Type: forward
                TargetGroupName:  '{{ecs_alb_name}}-targetgroup'
            Certificates:
              - CertificateArn: "arn:aws:acm:us-east-1:081137044412:certificate/6c474b98-a5a5-4f4f-9158-ada935b661ef"
            SslPolicy: ELBSecurityPolicy-2016-08
          - Protocol: HTTP
            Port: 80
            DefaultActions:
              - Type: forward
                TargetGroupName: '{{ecs_alb_name}}-targetgroup'

        state: present # not required. choices: present;absent. Create or destroy the load balancer.
        http2: true # not required. Indicates whether to enable HTTP2 routing.
        scheme: internet-facing # not required. choices: internet-facing;internal. Internet-facing or internal load balancer. An ELB scheme can not be modified after creation.
        validate_certs: yes # not required. When set to "no", SSL certificates will not be validated for boto versions >= 2.6.0.

  - name: "AWS | EC2 | Create a new EC2 Launch Configuration for ECS use (if non was found)"
    ec2_lc:
      name: "{{ ecs_cluster_name }}-lc"
      image_id: "{{ ecs_ami_id }}"
      key_name: "{{ ecs_ssh_key_name }}"
      security_groups: "{{ ecs_security_groups }}"
      instance_type: "{{ ecs_instance_type }}"
      assign_public_ip: "{{ ecs_assign_public_ip }}"
      region: "{{ ecs_ec2_region }}"
      instance_profile_name: "arn:aws:iam::081137044412:instance-profile/sg_watch_App_Dev_Lambda_Ecs_Permissions"
      user_data: |
        #!/bin/bash
        sudo yum install -y ecs-init
        sudo service docker start
        sudo chkconfig docker on
        sleep 45
        echo ECS_CLUSTER='{{ecs_cluster_name}}' >> /etc/ecs/ecs.config;
        echo ECS_BACKEND_HOST= >> /etc/ecs/ecs.config;
        sudo start ecs

      state: present
    register: ec2_new_lc

  - set_fact:
      ec2_ecs_lc_name: "{{ ec2_new_lc.name }}"

  - debug: var=ec2_ecs_lc_name verbosity=1
  - name: "AWS | EC2 | Define a EC2 Auto Scaling Group for ECS use"

    ec2_asg:
      name: "{{ ecs_asg_name }}"
      health_check_period: "{{ ecs_asg_health_check_period }}"
      health_check_type: "{{ ecs_asg_health_type }}"
      default_cooldown: "{{ ecs_asg_default_cooldown }}"
      replace_all_instances: "{{ ecs_asg_replace_all_instances }}"
      launch_config_name: "{{ ec2_ecs_lc_name }}"
      min_size: "{{ ecs_asg_min_size }}"
      max_size: "{{ ecs_asg_max_size }}"
      desired_capacity: "{{ ecs_asg_desired_capacity }}"
      vpc_zone_identifier: "{{ ecs_vpc_subnets }}"
      tags: "{{ ecs_ec2_tags }}"
      wait_for_instances: true
      region: "{{ ecs_ec2_region }}"
      target_group_arns: '{{elb_target_group.target_group_arn}}'
      state: present
    register: ec2_asg

  - debug: var=ec2_asg verbosity=2

  - name: get the latest docker image from ecr gearup_ service image
    shell: |
       aws ecr describe-images --repository-name gearup_pipeline --output text --query 'sort_by(imageDetails,& imagePushedAt)[*].imageTags[*]' | tr '\t' '\n' | tail -1
    register: gearup_services_image_id

  - name: Print details name
    debug: var=gearup_services_image_id.stdout

  - name: get the latest docker image from ecr gearup_api image
    shell: |
       aws ecr describe-images --repository-name gearup-api --output text --query 'sort_by(imageDetails,& imagePushedAt)[*].imageTags[*]' | tr '\t' '\n' | tail -1
    register: gearup_api_image_id

  - name: Print details name
    debug: var=gearup_api_image_id.stdout

  - name: get the latest docker image from ecr gearup_pipeline image
    shell: |
       aws ecr describe-images --repository-name gearup-nginx --output text --query 'sort_by(imageDetails,& imagePushedAt)[*].imageTags[*]' | tr '\t' '\n' | tail -1
    register: gearup_nginx_image_id

  - name: Print details name
    debug: var=gearup_nginx_image_id.stdout


  - name: Create task definition
    ecs_taskdefinition:
      family: gearup-pipeline
      state: present
      containers:
      - name: gearup-services
        cpu: 1024
        essential: true
        image: "081137044412.dkr.ecr.us-east-1.amazonaws.com/gearup_pipeline:{{gearup_services_image_id.stdout}}"
        memory: 2048
        environment:
        - name: MONGO_URL
          value: mongodb://root:SOh3TbYhx8ypJPxmt1oOfL@54.219.174.210:27017/healthhub_development?authSource=admin
        - name: NODE_ENV
          value: development
        - name: PORT
          value: 3001
        - name: ROOT_URL
          value: https://dev-services.samsunggearup.com
        portMappings:
        - containerPort: 3001
          hostPort: 3001
        logConfiguration:
          logDriver: awslogs
          options:
            awslogs-group: /ecs/gearup-dev
            awslogs-region: us-east-1
            awslogs-stream-prefix: ecs
      - name: gearup-api
        cpu: 512
        essential: true
        image: "081137044412.dkr.ecr.us-east-1.amazonaws.com/gearup-api:{{gearup_api_image_id.stdout}}"
        memory: 2048
        environment:
        - name: MONGO_URL
          value: mongodb://root:SOh3TbYhx8ypJPxmt1oOfL@54.219.174.210:27017/healthhub_development?authSource=admin
        - name: NODE_ENV
          value: development
        - name: CUSTOMER
          value: bridgecrest
        portMappings:
        - containerPort: 3000
          hostPort: 3000
        logConfiguration:
          logDriver: awslogs
          options:
            awslogs-group: /ecs/gearup-dev
            awslogs-region: us-east-1
            awslogs-stream-prefix: ecs
      - name: gearup-nginx
        cpu: 512
        essential: false
        image: "081137044412.dkr.ecr.us-east-1.amazonaws.com/gearup-nginx:{{gearup_nginx_image_id.stdout}}"
        memory: 2048
        environment:
        - name: Environment
          value: Development
        portMappings:
        - containerPort: 80
          hostPort: 80
        logConfiguration:
          logDriver: awslogs
          options:
            awslogs-group: /ecs/gearup-dev
            awslogs-region: us-east-1
            awslogs-stream-prefix: ecs
        links: ["gearup-api","gearup-services"]

    register: task_defination_output

  - name: Print details name
    debug: var=task_defination_output.taskdefinition["family"]


  - name: Print details Task revision
    debug: var=task_defination_output.taskdefinition["revision"]

  - name: Print details Task name and revision
    debug:
        msg: "{{  task_defination_output.taskdefinition[\"family\"]   }}:{{ task_defination_output.taskdefinition[\"revision\"] }}"

  - block:
    - name: creting or update services for the running cluster
      ecs_service:
        state: present
        name: gearup-deploy
        cluster: '{{ecs_cluster_name}}'
        task_definition: "{{  task_defination_output.taskdefinition[\"family\"]   }}:{{ task_defination_output.taskdefinition[\"revision\"] }}"
        desired_count: 2
      register: Deployed_service_output

    - name: Debug message for serices  Status
      debug: var=Deployed_service_output.service.status

    - name: Debug message for Services  name
      debug: var=Deployed_service_output.service.serviceName

    - name: Debug message for Services  ARN(AWS resource name) value
      debug: var=Deployed_service_output.service.serviceArn

    - name: Debug message for Cluster  ARN(AWS resource name) value
      debug: var=Deployed_service_output.service.clusterArn

